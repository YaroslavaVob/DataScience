import numpy as np
import pandas as pd

def get_education_type(education):
    """
    Применяется для столбца таблицы для отделения нужной информации из признака.
    С помощью метода str.split() разделяет значение на элементы-слова.
    С помощью метода .startswith() определяются нужные данные
     Args:
        education(str): признак (название столбца) таблицы 
    Returns:
        str: категория образования
    """
    education_list = education.split()
    if education_list[1].startswith('образ'):
        # возврат первого элемента-слова
        return education_list[0]
    else:
        # возврат первого и второго элементов
        return (' ').join(education_list[:2])  # объединение через пробел методом join()



def job_experience(experience):
    """
    Применяется для столбца таблицы для выделения нужной информации.
    * Создаются две переменные year и month, в которые будут сохранятся данные, относящиеся к опыту в годах и месяцах 
    соответственно, изначально равны 0.
    * Создаются списки с ключевыми словами, определяющими опыт в годах и в месяцах.
    * Если имеются пропуски, возвращаются как пропуски.
    * Каждое значение строки столбца разделяется на список(метод str.split()) 
    * Определяется информацию о годах и месяцах работы по ключевым словам и сохраняется в созданные переменные
    * Переменная year умножается на 12, чтобы подсчитать месяцы.
    Args:
        experience(str): признак (название столбца) таблицы 
    Returns:
        float: количество месяцев
    """
    year = 0
    month = 0
    # создаем списки с ключевыми словами для определения числовой информации
    year_list = ['лет', 'год', 'года']
    month_list = ['месяц', 'месяца', 'месяцев']
    # пропуски в данных и если информация обозначена как 'не указано' перезаписываем как пропуски
    if experience is np.nan or experience == 'Не указано':
        return np.nan
    # разбиваем строку на список слов
    experience = experience.split()[2:6]
    # циклом проходим по отделенным словам списка и сохраняем числа в переменные year и month
    for i, item in enumerate(experience):
        # если слово есть в списке ключенных слов, значит, берем число перед ним, определяющее это слово
        if item in year_list:
            year = int(experience[i-1])
        if item in month_list:
            month = int(experience[i-1])
    # года переводим в месяцы, возвращаем сумму всех месяцев
    return year*12 + month



def get_city(lst):
    """
    Применяется для столбца таблицы для отделения нужной информации и преобразовании в категории.
    Создается список с городами-миллионниками, города из этого списка будут отдельной категорией.
    Значение строки разбивается на список с помощью метода str.split()
    Классифицируется первый элемент списка-город по категориям.
    Args:
        lst(str): признак (название столбца) таблицы 
    Returns:
        str: категория города
    """
    # создаем список городов-миллионников
    million_cities = ['Новосибирск', 'Екатеринбург', 'Нижний Новгород', 'Казань', 'Челябинск', 'Омск', 'Самара', 
                     'Ростов-на-Дону', 'Уфа', 'Красноярск', 'Пермь', 'Воронеж', 'Волгоград' ]
    
    # разделяем строку на список с помощью метода split()и отделяем первый элемент-город
    cities = lst.split(' , ')[0]
    # разбиваем по категориям
    if cities == 'Москва':
        return 'Москва'
    elif cities == 'Санкт-Петербург':
        return 'Санкт-Петербург'
    elif cities in million_cities:
        return 'город-миллионник'
    else:
         return 'другие'



def move_city(lst):
    """
    Применяется для столбца таблицы для определения "да" или "нет" по информации в столбце 
    и создании отдельного признака с булевыми значениями.
    Строка-значение разбивается на список с помощью метода str.split(), отделяется нужная информация.
    Определяется "да" или "нет" с помощью поиска частицы 'не' в словах (элементах списка) методом startswith().
    Args:
        lst(str): признак (название столбца) таблицы 
    Returns:
        bool: булево значение True или False
    """
    # преобразование строки в список
    change_list = lst.split(' , ')[1:3]
    # определение частицы 'не'
    if change_list[0].startswith('не'):
        return False
    # если перед информацией по переезду указано метро, то переходим к следующему элементу списка про переезд
    elif change_list[0].startswith(' м.'):
        if change_list[1].startswith('не'):
            return False
        else:
            return True
    else:
        return True
    
        
    
def job_trip(lst):
    """
    Применяется для столбца таблицы для определения "да" или "нет" по информации в столбце
    и создании отдельного признака с булевыми значениями.
    Создается список с ключевыми словами.
    Строка-значение разбивается на список с помощью метода str.split(), отделяется нужная информация.
    Определяется "да" или "нет" по проверке ключевых слов.
    Args:
        lst(str): признак (название столбца) таблицы 
    Returns:
        bool: булево значение True или False
    """
    # создаем список ключевых слов
    list_trip = ['готов к командировкам', 'готова к командировкам', 
                 'готов к редким командировкам', 'готова к редким командировкам']
    # разделяем строку на список и отделяем последний элемент списка о командировках
    trip = lst.split(' , ')[-1]
    # соотносим элемент с ключевыми словами и определяем да или нет
    if trip in list_trip:
        return True
    else: 
        return False
    
    
    
def find_outliers_z_score(data, feature, left=3, right=3, log_scale=False):
    """
    Находит выбросы в данных, используя метод z-отклонений. 
    Классический метод модифицирован путем добавления:
    * возможности логарифмирования распредления
    * ручного управления количеством стандартных отклонений в обе стороны распределения
    Args:
        data (pandas.DataFrame): набор данных
        feature (str): имя признака, на основе которого происходит поиск выбросов
        left (float, optional): количество стандартных отклонений в левую сторону распределения. По умолчанию 1.5.
        right (float, optional): количество стандартных в правую сторону распределения. По умолчанию 1.5.
        log_scale (bool, optional): режим логарифмирования. По умолчанию False - логарифмирование не применяется.

    Returns:
        pandas.DataFrame: наблюдения, попавшие в разряд выбросов
        pandas.DataFrame: очищенные данные, из которых исключены выбросы
    """
    if log_scale:
        x = np.log(data[feature]+1)
    else:
        x = data[feature]
    mu = x.mean()
    sigma = x.std()
    lower_bound = mu - left * sigma
    upper_bound = mu + right * sigma
    outliers = data[(x < lower_bound) | (x > upper_bound)]
    cleaned = data[(x > lower_bound) & (x < upper_bound)]
    return outliers, cleaned
    
    
    